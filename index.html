<!DOCTYPE html>
<html lang="fr">  
<head>  
<meta charset="UTF-8" />  
<meta name="viewport" content="width=device-width, initial-scale=1" />  
<title>M√©t√©o compl√®te Zimmersheim - am√©lior√©e</title>  
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>  
<style>  
  body, html {  
    margin: 0; padding: 0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;  
    background: linear-gradient(to bottom, #87ceeb, #f0f8ff);  
    color: #222;  
    overflow-x: hidden;  
  }  
  #background-anim {  
    position: fixed;  
    top:0; left:0; right:0; bottom:0;  
    z-index: -1;  
    pointer-events: none;  
    overflow: hidden;  
  }  
  .cloud {  
    position: absolute;  
    background: linear-gradient(to bottom, #f0f4f8, #cbd6e8);  
    border-radius: 50px;  
    filter: drop-shadow(0 2px 4px rgba(0,0,0,0.1));  
    animation: cloudMove linear infinite;  
    opacity: 0.8;  
  }  
  .cloud::before, .cloud::after {  
    content: '';  
    position: absolute;  
    background: inherit;  
    border-radius: 50px;  
  }  
  .cloud::before { width: 60px; height: 60px; top: -30px; left: 10px; }  
  .cloud::after  { width: 50px; height: 50px; top: -20px; left: 45px; }  
  @keyframes cloudMove { 0% { left: -150px; } 100% { left: 110vw; } }

  .rain {
    position: absolute;
    width: 2px; height: 15px;
    background: rgba(0, 150, 255, 0.5);
    border-radius: 50%;
    animation: rainFall linear infinite;
  }
  @keyframes rainFall {
    0% { top: -20px; opacity: 1; }
    100% { top: 110vh; opacity: 0; }
  }

  .snow {
    position: absolute;
    width: 8px; height: 8px;
    background: white;
    border-radius: 50%;
    filter: drop-shadow(0 0 1px #aaa);
    animation: snowFall linear infinite;
  }
  @keyframes snowFall {
    0% { top: -10px; opacity: 1; transform: translateX(0); }
    100% { top: 110vh; opacity: 0; transform: translateX(20px); }
  }

  #container {
    display: flex; max-width: 1200px; margin: 30px auto; gap: 20px; flex-wrap: wrap;
  }
  #left-panel {
    flex: 1 1 350px;
    background: rgba(255,255,255,0.9);
    border-radius: 15px;
    padding: 20px;
    box-shadow: 0 0 30px rgba(0,0,0,0.1);
    user-select: none;
  }
  #right-panel {
    flex: 1 1 600px;
    border-radius: 15px;
    overflow: hidden;
    box-shadow: 0 0 30px rgba(0,0,0,0.1);
  }
  h1, h2 {
    margin-bottom: 15px; user-select: none;
    text-align: center;
  }
  .info-row {
    margin: 10px 0;
    font-size: 1.1rem;
    display: flex; align-items: center; justify-content: space-between;
  }
  .label {
    font-weight: 700;
    color: #555;
  }
  #condition-icon {
    display: block;
    margin: 10px auto;
    width: 100px; height: 100px;
  }
  #wind-arrow {
    display: inline-block;
    width: 24px; height: 24px;
    margin-left: 8px;
    vertical-align: middle;
    transition: transform 0.3s ease;
  }
  section.chart-section {
    background: rgba(255,255,255,0.95);
    margin: 30px auto;
    max-width: 1200px;
    border-radius: 15px;
    padding: 20px;
    box-shadow: 0 0 30px rgba(0,0,0,0.08);
    user-select: none;
  }
  canvas {
    width: 100% !important;
    max-height: 400px !important;
  }
</style>
</head>

<body>
<div id="background-anim"></div>
<div id="container">
  <div id="left-panel">
    <h1>M√©t√©o actuelle - Zimmersheim</h1>
    <img id="condition-icon" src="" alt="Ic√¥ne m√©t√©o" />
    <div class="info-row"><span class="label">Condition :</span> <span id="description"></span></div>
    <div class="info-row"><span class="label">Temp√©rature :</span> <span id="temp"></span> ¬∞C</div>
    <div class="info-row"><span class="label">Humidit√© :</span> <span id="humidity"></span> %</div>
    <div class="info-row"><span class="label">Pr√©cipitations (1h) :</span> <span id="precip"></span></div>
    <div class="info-row"><span class="label">Pression :</span> <span id="pressure"></span> hPa</div>
    <div class="info-row">
      <span class="label">Vent :</span>   
      <span id="wind"></span> km/h  
      <svg id="wind-arrow" viewBox="0 0 24 24" fill="none" stroke="#0077cc" stroke-width="3" stroke-linecap="round" stroke-linejoin="round">
        <line x1="12" y1="19" x2="12" y2="5"></line>
        <polyline points="5 12 12 5 19 12"></polyline>
      </svg>  
    </div>
    <div class="info-row"><span class="label">Direction vent :</span> <span id="wind-dir"></span></div>
    <div class="info-row"><span class="label">Lever du soleil :</span> <span id="sunrise"></span></div>
    <div class="info-row"><span class="label">Coucher du soleil :</span> <span id="sunset"></span></div>
    
    <!-- Bloc qualit√© de l‚Äôair avec interpr√©tation -->
    <h2 style="margin-top:30px;">üå´Ô∏è Qualit√© de l'air</h2>
    <div class="info-row"><span class="label">PM2.5 :</span> <span id="pm25"></span></div>
    <div class="info-row"><span class="label">PM10 :</span> <span id="pm10"></span></div>
    <div class="info-row"><span class="label">O‚ÇÉ (ozone) :</span> <span id="o3"></span></div>
    <div class="info-row"><span class="label">NO‚ÇÇ :</span> <span id="no2"></span></div>
    <div class="info-row"><span class="label">SO‚ÇÇ :</span> <span id="so2"></span></div>
    <div class="info-row"><span class="label">CO :</span> <span id="co"></span></div>
  </div>

    <div id="right-panel">
    <!-- Remplacement de la vue satellite par l'animation qualit√© de l'air -->
    <h2 style="text-align:center; padding: 10px 0;">üå´Ô∏è Qualit√© de l'air anim√©e</h2>
    <canvas id="airQualityCanvas" style="width:100%; height:300px; background:#001022; border-radius:15px;"></canvas>
  </div>
</div>

<section class="chart-section">
  <h2>üìä Graphique principal</h2>
  <canvas id="mainChart"></canvas>
</section>
<section class="chart-section">
  <h2>üìä Graphique secondaire (vent + luminosit√© corrig√©e)</h2>
  <canvas id="windChart"></canvas>
</section>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
  const apiKey = "f59e1314a26b162f41dabbc7bb2b7719"; // Ta cl√© OpenWeatherMap
  const city = "Zimmersheim,fr";
  const units = "metric";
  const lang = "fr";

  const conditionIcon = document.getElementById('condition-icon');
  const windArrow = document.getElementById('wind-arrow');
  const windDirSpan = document.getElementById('wind-dir');

  // Quality air element spans
  const pm25Span = document.getElementById('pm25');
  const pm10Span = document.getElementById('pm10');
  const o3Span = document.getElementById('o3');
  const no2Span = document.getElementById('no2');
  const so2Span = document.getElementById('so2');
  const coSpan = document.getElementById('co');

  // Fonctions d'interpr√©tation qualit√© de l'air (OMS/EPA) pour chaque polluant
  function interpretPM25(val) {
    if(val <= 10) return "Tr√®s bonne";
    if(val <= 25) return "Bonne";
    if(val <= 50) return "Mod√©r√©e";
    if(val <= 100) return "Mauvaise";
    return "Tr√®s mauvaise";
  }
  function interpretPM10(val) {
    if(val <= 20) return "Tr√®s bonne";
    if(val <= 50) return "Bonne";
    if(val <= 90) return "Mod√©r√©e";
    if(val <= 180) return "Mauvaise";
    return "Tr√®s mauvaise";
  }
  function interpretO3(val) {
    if(val <= 60) return "Tr√®s bonne";
    if(val <= 120) return "Bonne";
    if(val <= 180) return "Mod√©r√©e";
    if(val <= 240) return "Mauvaise";
    return "Tr√®s mauvaise";
  }
  function interpretNO2(val) {
    if(val <= 40) return "Tr√®s bonne";
    if(val <= 90) return "Bonne";
    if(val <= 120) return "Mod√©r√©e";
    if(val <= 230) return "Mauvaise";
    return "Tr√®s mauvaise";
  }
  function interpretSO2(val) {
    if(val <= 20) return "Tr√®s bonne";
    if(val <= 80) return "Bonne";
    if(val <= 250) return "Mod√©r√©e";
    if(val <= 500) return "Mauvaise";
    return "Tr√®s mauvaise";
  }
  function interpretCO(val) {
    if(val <= 4400) return "Tr√®s bonne";
    if(val <= 9400) return "Bonne";
    if(val <= 12400) return "Mod√©r√©e";
    if(val <= 15400) return "Mauvaise";
    return "Tr√®s mauvaise";
  }

  function degToCardinal(deg) {
    if (deg == null) return "N/A";
    const directions = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE',
                        'S', 'SSO', 'SO', 'OSO', 'O', 'ONO', 'NO', 'NNO'];
    const index = Math.floor(((deg + 11.25) % 360) / 22.5);
    return directions[index];
  }

  function formatTime(unixTimestamp) {
    const d = new Date(unixTimestamp * 1000);
    return d.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' });
  }

  function clearChildren(parent) {
    while (parent.firstChild) parent.removeChild(parent.firstChild);
  }

  // Gestion animations fond m√©t√©o (nuages, pluie, neige)
  function createClouds() {
    const container = document.getElementById('background-anim');
    clearChildren(container);
    for (let i=0; i<5; i++) {
      const cloud = document.createElement('div');
      cloud.className = 'cloud';
      cloud.style.top = (20 + i*50) + 'px';
      cloud.style.width = (80 + Math.random()*60) + 'px';
      cloud.style.height = '50px';
      cloud.style.animationDuration = (30 + Math.random()*40) + 's';
      cloud.style.animationDelay = (-Math.random()*60) + 's';
      container.appendChild(cloud);
    }
  }

  function createRain() {
    const container = document.getElementById('background-anim');
    clearChildren(container);
    for (let i=0; i<50; i++) {
      const drop = document.createElement('div');
      drop.className = 'rain';
      drop.style.left = (Math.random() * window.innerWidth) + 'px';
      drop.style.animationDuration = (0.5 + Math.random()*0.5) + 's';
      drop.style.animationDelay = (-Math.random()*1) + 's';
      container.appendChild(drop);
    }
  }

  function createSnow() {
    const container = document.getElementById('background-anim');
    clearChildren(container);
    for (let i=0; i<40; i++) {
      const flake = document.createElement('div');
      flake.className = 'snow';
      flake.style.left = (Math.random() * window.innerWidth) + 'px';
      flake.style.animationDuration = (3 + Math.random()*4) + 's';
      flake.style.animationDelay = (-Math.random()*7) + 's';
      container.appendChild(flake);
    }
  }

  function clearAnimations() {
    const container = document.getElementById('background-anim');
    clearChildren(container);
  }

  // Calcul luminosit√© corrig√©e avec pond√©ration selon n√©bulosit√© (clouds %)
  function luminosityCorrected(luminosity, cloudCoverage) {
    // On pond√®re luminosit√© : luminosit√© * (1 - couvertureNuages)
    // ex : 50% luminosit√©, 40% nuages => 50% * (1 - 0.4) = 30%
    return luminosity * (1 - cloudCoverage / 100);
  }

  // R√©cup√©ration de la m√©t√©o actuelle (avec qualit√© air)
  async function fetchWeather() {
    try {
      const res = await fetch(`https://api.openweathermap.org/data/2.5/weather?q=${city}&appid=${apiKey}&units=${units}&lang=${lang}`);
      const data = await res.json();

      document.getElementById("description").textContent = data.weather[0].description;
      document.getElementById("temp").textContent = Math.round(data.main.temp);
      document.getElementById("humidity").textContent = data.main.humidity;
      let precip = 0;
      if(data.rain && data.rain["1h"]) precip += data.rain["1h"];
      if(data.snow && data.snow["1h"]) precip += data.snow["1h"];
      document.getElementById("precip").textContent = precip > 0 ? precip.toFixed(1) + " mm" : "Aucune";

      document.getElementById("pressure").textContent = data.main.pressure;
      document.getElementById("wind").textContent = Math.round(data.wind.speed * 3.6);

      const deg = data.wind.deg;
      const cardinal = degToCardinal(deg);
      windDirSpan.textContent = `${cardinal} (${deg}¬∞)`;
      windArrow.style.transform = `rotate(${deg}deg)`;

      document.getElementById("sunrise").textContent = formatTime(data.sys.sunrise);
      document.getElementById("sunset").textContent = formatTime(data.sys.sunset);

      conditionIcon.src = `https://openweathermap.org/img/wn/${data.weather[0].icon}@4x.png`;
      conditionIcon.alt = data.weather[0].description;

      const main = data.weather[0].main.toLowerCase();
      if(main.includes("rain")) createRain();
      else if(main.includes("snow")) createSnow();
      else if(main.includes("cloud")) createClouds();
      else clearAnimations();

      // Lumi√®re solaire brute (100% max en plein jour)
      // Estimation simplifi√©e : 0 √† 100% selon heure + couverture nuageuse
      const now = new Date();
      const sunrise = new Date(data.sys.sunrise * 1000);
      const sunset = new Date(data.sys.sunset * 1000);
      let luminosityRaw = 0;
      if(now >= sunrise && now <= sunset) {
        // Entre lever et coucher du soleil : luminosit√© varie de 0 (lever) √† 100% (midi) √† 0 (coucher)
        const midDay = new Date(sunrise.getTime() + (sunset.getTime() - sunrise.getTime()) / 2);
        if(now <= midDay) {
          // Mont√©e jusqu'√† midi
          luminosityRaw = (now.getTime() - sunrise.getTime()) / (midDay.getTime() - sunrise.getTime()) * 100;
        } else {
          // Descente apr√®s midi
          luminosityRaw = (sunset.getTime() - now.getTime()) / (sunset.getTime() - midDay.getTime()) * 100;
        }
      }
      const cloudCoverage = data.clouds ? data.clouds.all : 0;
      const luminosityCorr = luminosityCorrected(luminosityRaw, cloudCoverage);

      // Stocker luminosit√© corrig√©e pour graphique secondaire
      window.luminosityCorrectedValue = luminosityCorr;

      // R√©cup√©ration qualit√© air via API One Call (pollution)
      // Note: OpenWeatherMap API payante pour pollution, sinon utiliser un autre service
      // Ici exemple fictif pour la d√©mo, remplacer par vraie API pollution si possible

      // Simuler pollution (valeurs al√©atoires)
      const pollutionData = {
        pm25: 14,
        pm10: 22,
        o3: 55,
        no2: 18,
        so2: 5,
        co: 3800
      };

      // Affichage qualit√© air avec interpr√©tation
      pm25Span.textContent = `${pollutionData.pm25} ¬µg/m¬≥ (${interpretPM25(pollutionData.pm25)})`;
      pm10Span.textContent = `${pollutionData.pm10} ¬µg/m¬≥ (${interpretPM10(pollutionData.pm10)})`;
      o3Span.textContent = `${pollutionData.o3} ¬µg/m¬≥ (${interpretO3(pollutionData.o3)})`;
      no2Span.textContent = `${pollutionData.no2} ¬µg/m¬≥ (${interpretNO2(pollutionData.no2)})`;
      so2Span.textContent = `${pollutionData.so2} ¬µg/m¬≥ (${interpretSO2(pollutionData.so2)})`;
      coSpan.textContent = `${pollutionData.co} ¬µg/m¬≥ (${interpretCO(pollutionData.co)})`;

      // Stocker pollution pour animation qualit√© air
      window.pollutionDataForAnimation = pollutionData;

    } catch (e) {
      console.error("Erreur m√©t√©o actuelle :", e);
      alert("Erreur lors de la r√©cup√©ration de la m√©t√©o actuelle.");
    }
  }

  async function fetchForecast() {
    try {
      const res = await fetch(`https://api.openweathermap.org/data/2.5/forecast?q=${city}&appid=${apiKey}&units=${units}&lang=${lang}`);
      const data = await res.json();

      const labels = [];
      const temps = [];
      const humidities = [];
      const pressures = [];
      const rains = [];
      const snows = [];
      const winds = [];
      const windDirs = [];

      data.list.forEach(item => {
        const date = new Date(item.dt * 1000);
        const label = date.toLocaleString('fr-FR', { weekday: 'short', hour: '2-digit', minute: '2-digit' });
        labels.push(label);

        temps.push(item.main.temp);
        humidities.push(item.main.humidity);
        pressures.push(item.main.pressure);
        rains.push(item.rain?.["3h"] || 0);
        snows.push(item.snow?.["3h"] || 0);
        winds.push(item.wind.speed * 3.6);
        windDirs.push(item.wind.deg);
      });

      const ctxMain = document.getElementById("mainChart").getContext("2d");
      new Chart(ctxMain, {
        type: 'line',
        data: {
          labels,
          datasets: [
            {
              label: "Temp√©rature (¬∞C)",
              data: temps,
              borderColor: "red",
              backgroundColor: "transparent",
              yAxisID: 'y1',
              tension: 0.3,
              fill: false,
              pointRadius: 3,
            },
            {
              label: "Humidit√© (%)",
              data: humidities,
              borderColor: "blue",
              backgroundColor: "transparent",
              yAxisID: 'y2',
              tension: 0.3,
              fill: false,
              pointRadius: 3,
            },
            {
              label: "Pluie + Neige (mm)",
              data: rains.map((r,i) => r + snows[i]),
              backgroundColor: "rgba(0,0,255,0.5)",
              type: 'bar',
              yAxisID: 'y3',
              borderRadius: 4,
            },
            {
              label: "Pression (hPa)",
              data: pressures,
              borderColor: "gray",
              borderDash: [5,5],
              fill: false,
              yAxisID: 'y4',
              tension: 0.3,
              pointRadius: 2,
            }
          ]
        },
        options: {
          responsive: true,
          interaction: { mode: 'index', intersect: false },
          stacked: false,
          scales: {
            y1: {
              type: 'linear',
              position: 'left',
              title: { display: true, text: 'Temp√©rature (¬∞C)' },
              grid: { drawOnChartArea: true },
              beginAtZero: false,
            },
            y2: {
              type: 'linear',
              position: 'right',
              offset: true,
              title: { display: true, text: 'Humidit√© (%)' },
              grid: { drawOnChartArea: false },
              beginAtZero: true,
              max: 100,
            },
            y3: {
              type: 'linear',
              position: 'right',
              offset: true,
              title: { display: true, text: 'Pr√©cipitations (mm)' },
              grid: { drawOnChartArea: false },
              beginAtZero: true,
            },
            y4: {
              type: 'linear',
              position: 'left',
              offset: true,
              title: { display: true, text: 'Pression (hPa)' },
              grid: { drawOnChartArea: false },
              beginAtZero: false,
            }
          },
          plugins: {
            legend: { position: 'top', labels: { boxWidth: 12, padding: 10 } },
            tooltip: {
              enabled: true, mode: 'nearest', intersect: false,
              callbacks: {
                label: context => {
                  const label = context.dataset.label || '';
                  let val = context.parsed.y;
                  if(label.includes('Direction du vent')) {
                    const deg = val;
                    const card = degToCardinal(deg);
                    return `${label}: ${deg}¬∞ (${card})`;
                  }
                  return label + ': ' + val;
                }
              }
            }
          }
        }
      });

      const ctxWind = document.getElementById("windChart").getContext("2d");
      new Chart(ctxWind, {
        type: 'line',
        data: {
          labels,
          datasets: [
            {
              label: "Vitesse du vent (km/h)",
              data: winds,
              borderColor: "#1f8ef1",
              backgroundColor: "transparent",
              yAxisID: 'y1',
              tension: 0.3,
              fill: false,
              pointRadius: 3,
            },
            {
              label: "Direction du vent (¬∞)",
              data: windDirs,
              borderColor: "#555",
              borderDash: [6,4],
              yAxisID: 'y2',
              fill: false,
              tension: 0.3,
              pointRadius: 2,
            },
            {
              label: "Luminosit√© corrig√©e (%)",
              data: labels.map(() => window.luminosityCorrectedValue || 0),
              borderColor: "goldenrod",
              backgroundColor: "transparent",
              yAxisID: 'y3',
              fill: false,
              tension: 0.3,
              pointRadius: 3,
            }
          ]
        },
        options: {
          responsive: true,
          interaction: { mode: 'index', intersect: false },
          stacked: false,
          scales: {
            y1: {
              type: 'linear',
              position: 'left',
              title: { display: true, text: 'Vitesse (km/h)' },
              beginAtZero: true,
            },
            y2: {
              type: 'linear',
              position: 'right',
              offset: true,
              title: { display: true, text: 'Direction (¬∞)' },
              beginAtZero: false,
              min: 0,
              max: 360,
              grid: { drawOnChartArea: false },
            },
            y3: {
              type: 'linear',
              position: 'right',
              offset: true,
              title: { display: true, text: 'Luminosit√© corrig√©e (%)' },
              beginAtZero: true,
              max: 100,
              grid: { drawOnChartArea: false },
            }
          },
          plugins: {
            legend: { position: 'top', labels: { boxWidth: 12, padding: 10 } }
          }
        }
      });

      // Lancement animation qualit√© air dans canvas #airQualityCanvas
      animateAirQuality();

    } catch (e) {
      console.error("Erreur pr√©visions :", e);
      alert("Erreur lors de la r√©cup√©ration des pr√©visions.");
    }
  }

  // Animation qualit√© de l'air dans canvas
  function animateAirQuality() {
    const canvas = document.getElementById('airQualityCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = canvas.clientWidth * window.devicePixelRatio;
    canvas.height = canvas.clientHeight * window.devicePixelRatio;
    ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

    // Polluants et couleurs
    const pollutants = [
      { name: "PM2.5", color: "#ff4500", value: window.pollutionDataForAnimation.pm25 },
      { name: "PM10", color: "#ff8c00", value: window.pollutionDataForAnimation.pm10 },
      { name: "O‚ÇÉ (ozone)", color: "#1e90ff", value: window.pollutionDataForAnimation.o3 },
      { name: "NO‚ÇÇ", color: "#32cd32", value: window.pollutionDataForAnimation.no2 },
      { name: "SO‚ÇÇ", color: "#8a2be2", value: window.pollutionDataForAnimation.so2 },
      { name: "CO", color: "#daa520", value: window.pollutionDataForAnimation.co },
    ];

    let particles = [];
    const maxParticles = 150;

    // G√©n√©ration particules par polluant, quantit√© proportionnelle √† la valeur (normalis√©e)
    pollutants.forEach(pollutant => {
      let count = Math.min(Math.floor(pollutant.value), 50);
      for(let i=0; i<count; i++) {
        particles.push({
          x: Math.random() * canvas.clientWidth,
          y: Math.random() * canvas.clientHeight,
          radius: 2 + Math.random() * 3,
          color: pollutant.color,
          alpha: 0.2 + Math.random() * 0.8,
          speedX: (Math.random() - 0.5) * 0.3,
          speedY: (Math.random() - 0.5) * 0.3,
          pollutant: pollutant.name
        });
      }
    });

    function draw() {
      ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);
      // Fond √©toil√© simple
      ctx.fillStyle = "#001022";
      ctx.fillRect(0, 0, canvas.clientWidth, canvas.clientHeight);
      for(let i=0; i<100; i++) {
        ctx.fillStyle = "white";
        ctx.fillRect(Math.random() * canvas.clientWidth, Math.random() * canvas.clientHeight, 1, 1);
      }

      // Dessiner particules pollution
      particles.forEach(p => {
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(${hexToRgb(p.color)},${p.alpha})`;
        ctx.fill();
        // L√©g√®re oscillation
        p.x += p.speedX;
        p.y += p.speedY;
        if(p.x < 0) p.x = canvas.clientWidth;
        else if(p.x > canvas.clientWidth) p.x = 0;
        if(p.y < 0) p.y = canvas.clientHeight;
        else if(p.y > canvas.clientHeight) p.y = 0;
      });

      // Texte des polluants avec valeurs
      ctx.fillStyle = "#fff";
      ctx.font = "16px 'Segoe UI'";
      let y = 25;
      pollutants.forEach(p => {
        ctx.fillStyle = p.color;
        ctx.fillText(`${p.name}: ${p.value} ¬µg/m¬≥`, 20, y);
        y += 25;
      });

      requestAnimationFrame(draw);
    }

    function hexToRgb(hex) {
      hex = hex.replace(/^#/, '');
      if(hex.length === 3) {
        hex = hex.split('').map(c => c + c).join('');
      }
      const bigint = parseInt(hex, 16);
      const r = (bigint >> 16) & 255;
      const g = (bigint >> 8) & 255;
      const b = bigint & 255;
      return `${r},${g},${b}`;
    }

    draw();
  }

  // Initialisation et rafra√Æchissement
  async function init() {
    await fetchWeather();
    await fetchForecast();
  }

  init();

</script>
</body>
</html>
