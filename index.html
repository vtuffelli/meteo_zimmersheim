<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>M√©t√©o compl√®te Zimmersheim - am√©lior√©e</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
  body, html {
    margin: 0; padding: 0;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: linear-gradient(to bottom, #00111f, #002644);
    color: #eee;
    overflow-x: hidden;
  }
  /* Fond anim√© g√©n√©ral */
  #background-anim {
    position: fixed;
    top:0; left:0; right:0; bottom:0;
    z-index: -1;
    pointer-events: none;
    overflow: hidden;
    background: transparent;
  }
  /* √âtoiles */
  .star {
    position: absolute;
    background: white;
    border-radius: 50%;
    opacity: 0.8;
    animation: twinkle 3s infinite alternate;
  }
  @keyframes twinkle {
    0% {opacity: 0.8;}
    100% {opacity: 0.2;}
  }
  /* Lune stylis√©e */
  #moon {
    position: absolute;
    width: 120px;
    height: 120px;
    border-radius: 50%;
    background: radial-gradient(circle at 30% 30%, #f0e9d2, #a8997a);
    box-shadow:
      inset -15px -15px 20px #c9b98a,
      10px 10px 15px rgba(255,255,200,0.3);
    top: 50px;
    right: 50px;
    filter: drop-shadow(0 0 8px #fffacd88);
  }
  /* Nuages anim√©s */
  .cloud {
    position: absolute;
    background: linear-gradient(to bottom, #ccc, #eee);
    border-radius: 50px;
    filter: drop-shadow(0 2px 4px rgba(0,0,0,0.2));
    animation: cloudMove linear infinite;
    opacity: 0.85;
  }
  .cloud::before, .cloud::after {
    content: '';
    position: absolute;
    background: inherit;
    border-radius: 50px;
  }
  .cloud::before {
    width: 60px; height: 60px;
    top: -30px; left: 10px;
  }
  .cloud::after {
    width: 50px; height: 50px;
    top: -20px; left: 45px;
  }
  @keyframes cloudMove {
    0% { left: -150px; }
    100% { left: 110vw; }
  }
  /* Pluie anim√©e */
  .rain {
    position: absolute;
    width: 2px; height: 15px;
    background: rgba(0, 150, 255, 0.5);
    border-radius: 50%;
    animation: rainFall linear infinite;
  }
  @keyframes rainFall {
    0% { top: -20px; opacity: 1; }
    100% { top: 110vh; opacity: 0; }
  }
  /* Neige anim√©e */
  .snow {
    position: absolute;
    width: 8px; height: 8px;
    background: white;
    border-radius: 50%;
    filter: drop-shadow(0 0 1px #aaa);
    animation: snowFall linear infinite;
  }
  @keyframes snowFall {
    0% { top: -10px; opacity: 1; transform: translateX(0); }
    100% { top: 110vh; opacity: 0; transform: translateX(20px); }
  }
  /* Pulsation image qualit√© air */
  @keyframes pulse {
    0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
    50% { transform: translate(-50%, -50%) scale(1.1); opacity: 0.7; }
  }

  #container {
    display: flex;
    max-width: 1200px;
    margin: 30px auto;
    gap: 20px;
    flex-wrap: wrap;
  }
  #left-panel {
    flex: 1 1 350px;
    background: rgba(0,0,0,0.65);
    border-radius: 15px;
    padding: 20px;
    box-shadow: 0 0 30px rgba(0,0,0,0.7);
    user-select: none;
    color: #ddd;
  }
  #right-panel {
    flex: 1 1 600px;
    background: rgba(0,0,0,0.65);
    border-radius: 15px;
    padding: 15px;
    box-shadow: 0 0 30px rgba(0,0,0,0.7);
    color: #ddd;
  }

  #condition-icon {
    display: block;
    margin: 10px auto;
    width: 100px; height: 100px;
  }

  /* Fl√®che direction vent (taille fixe) */
  #wind-arrow {
    display: inline-block;
    width: 24px;
    height: 24px;
    margin-left: 8px;
    vertical-align: middle;
    transition: transform 0.3s ease;
  }

  h1, h2, h3 {
    margin-bottom: 15px;
    user-select: none;
    text-align: center;
    color: #eee;
  }

  .info-row {
    margin: 10px 0;
    font-size: 1.1rem;
    display: flex;
    align-items: center;
    justify-content: space-between;
    color: #ccc;
  }
  .label {
    font-weight: 700;
    color: #aaa;
  }

  /* Cadre Qualit√© de l'air √† la place de la carte */
  #airQualityContainer {
    border: 2px solid #3e8e41;
    padding: 15px;
    border-radius: 10px;
    max-width: 350px;
    background: radial-gradient(circle at center, #e0f7fa 0%, #a0d8ef 70%);
    position: relative;
    overflow: hidden;
    margin: 0 auto 20px auto;
    color: #004d40;
  }
  #airQualityAnimated {
    position: relative;
    width: 100%;
    height: 120px;
    margin-bottom: 15px;
  }
  #airQualityAnimated img {
    width: 100px;
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    animation: pulse 3s infinite;
  }
  #airQualityList {
    list-style: none;
    padding: 0;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    font-size: 14px;
    color: #004d40;
  }

  /* Graphiques sections */
  section.chart-section {
    background: rgba(0,0,0,0.65);
    margin: 30px auto;
    max-width: 1200px;
    border-radius: 15px;
    padding: 20px;
    box-shadow: 0 0 30px rgba(0,0,0,0.7);
    user-select: none;
    color: #ddd;
  }
  canvas {
    width: 100% !important;
    max-height: 400px !important;
  }
</style>
</head>
<body>
  <div id="background-anim"></div>
  <div id="moon"></div>

  <div id="container">
    <div id="left-panel">
      <h1>M√©t√©o actuelle - Zimmersheim</h1>
      <img id="condition-icon" src="" alt="Ic√¥ne m√©t√©o" />
      <div class="info-row"><span class="label">Condition :</span> <span id="description"></span></div>
      <div class="info-row"><span class="label">Temp√©rature :</span> <span id="temp"></span> ¬∞C</div>
      <div class="info-row"><span class="label">Humidit√© :</span> <span id="humidity"></span> %</div>
      <div class="info-row"><span class="label">Pr√©cipitations (1h) :</span> <span id="precip"></span></div>
      <div class="info-row"><span class="label">Pression :</span> <span id="pressure"></span> hPa</div>
      <div class="info-row">
        <span class="label">Vent :</span>
        <span id="wind"></span> km/h
        <svg id="wind-arrow" viewBox="0 0 24 24" fill="none" stroke="#00aaff" stroke-width="3" stroke-linecap="round" stroke-linejoin="round">
          <line x1="12" y1="19" x2="12" y2="5"></line>
          <polyline points="5 12 12 5 19 12"></polyline>
        </svg>
      </div>
      <div class="info-row">
        <span class="label">Direction vent :</span>
        <span id="wind-dir"></span>
      </div>
      <div class="info-row"><span class="label">Lever du soleil :</span> <span id="sunrise"></span></div>
      <div class="info-row"><span class="label">Coucher du soleil :</span> <span id="sunset"></span></div>
    </div>

    <div id="right-panel">
      <h3>Qualit√© de l'air</h3>
      <div id="airQualityContainer">
        <div id="airQualityAnimated">
          <img src="https://upload.wikimedia.org/wikipedia/commons/4/4e/Air_pollution_icon.svg" alt="Air Quality Icon" />
        </div>
        <ul id="airQualityList">
          <!-- Polluants inject√©s ici -->
        </ul>
      </div>
    </div>
  </div>

  <section class="chart-section">
    <h2>üìä Graphique principal</h2>
    <canvas id="mainChart"></canvas>
  </section>

  <section class="chart-section">
    <h2>üìä Graphique secondaire (vent, UV, luminosit√©)</h2>
    <canvas id="windChart"></canvas>
  </section>

  <section class="chart-section">
    <h2>üìä Graphique qualit√© de l'air</h2>
    <canvas id="airChart"></canvas>
  </section>

<script>
  const apiKey = "f59e1314a26b162f41dabbc7bb2b7719"; // ta cl√© OpenWeatherMap
  const city = "Zimmersheim,fr";
  const units = "metric";
  const lang = "fr";

  const conditionIcon = document.getElementById('condition-icon');
  const windArrow = document.getElementById('wind-arrow');
  const windDirSpan = document.getElementById('wind-dir');

  function degToCardinal(deg) {
    if (deg == null) return "N/A";
    const directions = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE',
                        'S', 'SSO', 'SO', 'OSO', 'O', 'ONO', 'NO', 'NNO'];
    const index = Math.floor(((deg + 11.25) % 360) / 22.5);
    return directions[index];
  }

  function formatTime(unixTimestamp) {
    const d = new Date(unixTimestamp * 1000);
    return d.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' });
  }

  function clearChildren(parent) {
    while (parent.firstChild) parent.removeChild(parent.firstChild);
  }

  // Cr√©e √©toiles anim√©es
  function createStars() {
    const container = document.getElementById('background-anim');
    // on garde max 100 √©toiles
    for(let i = 0; i < 100; i++) {
      const star = document.createElement('div');
      star.className = 'star';
      star.style.width = (Math.random()*2 + 1) + 'px';
      star.style.height = star.style.width;
      star.style.top = (Math.random() * window.innerHeight) + 'px';
      star.style.left = (Math.random() * window.innerWidth) + 'px';
      star.style.animationDuration = (2 + Math.random()*3) + 's';
      star.style.animationDelay = (Math.random()*3) + 's';
      container.appendChild(star);
    }
  }

  // Nuages anim√©s
  function createClouds() {
    const container = document.getElementById('background-anim');
    clearChildren(container);
    for (let i=0; i<5; i++) {
      const cloud = document.createElement('div');
      cloud.className = 'cloud';
      cloud.style.top = (20 + i*50) + 'px';
      cloud.style.width = (80 + Math.random()*60) + 'px';
      cloud.style.height = '50px';
      cloud.style.animationDuration = (30 + Math.random()*40) + 's';
      cloud.style.animationDelay = (-Math.random()*60) + 's';
      container.appendChild(cloud);
    }
  }

  // Pluie anim√©e
  function createRain() {
    const container = document.getElementById('background-anim');
    clearChildren(container);
    for (let i=0; i<50; i++) {
      const drop = document.createElement('div');
      drop.className = 'rain';
      drop.style.left = (Math.random() * window.innerWidth) + 'px';
      drop.style.animationDuration = (0.5 + Math.random()*0.5) + 's';
      drop.style.animationDelay = (-Math.random()*1) + 's';
      container.appendChild(drop);
    }
  }

  // Neige anim√©e
  function createSnow() {
    const container = document.getElementById('background-anim');
    clearChildren(container);
    for (let i=0; i<40; i++) {
      const flake = document.createElement('div');
      flake.className = 'snow';
      flake.style.left = (Math.random() * window.innerWidth) + 'px';
      flake.style.animationDuration = (3 + Math.random()*4) + 's';
      flake.style.animationDelay = (-Math.random()*7) + 's';
      container.appendChild(flake);
    }
  }

  // Supprime toutes animations (nuages, pluie, neige, √©toiles)
  function clearAnimations() {
    const container = document.getElementById('background-anim');
    while (container.firstChild) container.removeChild(container.firstChild);
  }

  // Ajuste luminosit√© corrig√©e par n√©bulosit√© (couverture nuageuse en %)
  function luminosityCorrected(rawPercent, cloudPercent) {
    // Par exemple, on diminue la luminosit√© de 70% √† 100% de couverture nuageuse
    const factor = 1 - (cloudPercent / 100) * 0.7;
    return rawPercent * factor;
  }

  <script>
  // Phase lune calcul simple (0=lune nouvelle, 0.5=pleine lune)
  function getMoonPhase(date) {
    // Source approximation: https://www.subsystems.us/uploads/9/8/9/4/98948044/moonphase.pdf
    const lp = 2551443; // dur√©e lunaison en sec
    const new_moon = new Date(1970, 0, 7, 20, 35, 0); // r√©f√©rence
    const phase = ((date.getTime() - new_moon.getTime())/1000) % lp;
    return phase / lp;
  }

  // Convert phase lune en emoji ou texte
  function moonPhaseEmoji(phase) {
    if (phase < 0.03 || phase > 0.97) return 'üåë Nouvelle lune';
    if (phase < 0.22) return 'üåí Premier croissant';
    if (phase < 0.28) return 'üåì Premier quartier';
    if (phase < 0.47) return 'üåî Lune gibbeuse croissante';
    if (phase < 0.53) return 'üåï Pleine lune';
    if (phase < 0.72) return 'üåñ Lune gibbeuse d√©croissante';
    if (phase < 0.78) return 'üåó Dernier quartier';
    if (phase < 0.97) return 'üåò Dernier croissant';
    return '';
  }

  // Format heure ISO en heure locale
  function formatLocalHour(dateISO) {
    const d = new Date(dateISO);
    return d.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' });
  }

  // Variables globales ChartJS (pour mise √† jour propre)
  let mainChartInstance = null;
  let windChartInstance = null;
  let airChartInstance = null;

  // Stockage donn√©es qualit√© air pour graphique
  let airPollutantsLabels = ["PM2.5", "PM10", "O3", "NO2", "SO2", "CO"];
  let airPollutantsKeys = ["pm2_5", "pm10", "o3", "no2", "so2", "co"];

  async function fetchWeather() {
    try {
      const res = await fetch(`https://api.openweathermap.org/data/2.5/weather?q=${city}&appid=${apiKey}&units=${units}&lang=${lang}`);
      const data = await res.json();

      // Mise √† jour infos actuelles
      document.getElementById("description").textContent = data.weather[0].description;
      document.getElementById("temp").textContent = Math.round(data.main.temp);
      document.getElementById("humidity").textContent = data.main.humidity;

      // Pr√©cipitations 1h
      let precip = 0;
      if(data.rain && data.rain["1h"]) precip += data.rain["1h"];
      if(data.snow && data.snow["1h"]) precip += data.snow["1h"];
      document.getElementById("precip").textContent = precip > 0 ? precip.toFixed(1) + " mm" : "Aucune";

      document.getElementById("pressure").textContent = data.main.pressure;
      document.getElementById("wind").textContent = Math.round(data.wind.speed * 3.6);

      // Direction vent cardinal + rotation fl√®che
      const deg = data.wind.deg;
      const cardinal = degToCardinal(deg);
      windDirSpan.textContent = `${cardinal} (${deg}¬∞)`;
      windArrow.style.transform = `rotate(${deg}deg)`;

      document.getElementById("sunrise").textContent = formatTime(data.sys.sunrise);
      document.getElementById("sunset").textContent = formatTime(data.sys.sunset);

      conditionIcon.src = `https://openweathermap.org/img/wn/${data.weather[0].icon}@4x.png`;
      conditionIcon.alt = data.weather[0].description;

      // Fond anim√© selon m√©t√©o principale
      const main = data.weather[0].main.toLowerCase();
      if(main.includes("rain")) createRain();
      else if(main.includes("snow")) createSnow();
      else if(main.includes("cloud")) createClouds();
      else {
        clearAnimations();
        createStars();
      }

      // Lune affichage texte √† gauche panel (phase actuelle)
      const now = new Date();
      const phase = getMoonPhase(now);
      let moonText = moonPhaseEmoji(phase);
      // Ajout √©l√©ment lune texte s'il n'existe pas
      if(!document.getElementById('moonPhaseText')){
        const p = document.createElement('p');
        p.id = 'moonPhaseText';
        p.style.textAlign = 'center';
        p.style.marginTop = '15px';
        p.style.color = '#eee';
        p.style.fontWeight = '700';
        document.getElementById('left-panel').appendChild(p);
      }
      document.getElementById('moonPhaseText').textContent = `Phase de lune : ${moonText}`;

      return data; // m√©t√©o actuelle
    } catch (e) {
      console.error("Erreur m√©t√©o actuelle :", e);
      alert("Erreur lors de la r√©cup√©ration de la m√©t√©o actuelle.");
      return null;
    }
  }

  async function fetchForecast() {
    try {
      const res = await fetch(`https://api.openweathermap.org/data/2.5/forecast?q=${city}&appid=${apiKey}&units=${units}&lang=${lang}`);
      const data = await res.json();

      const labels = [];
      const temps = [];
      const humidities = [];
      const pressures = [];
      const rains = [];
      const snows = [];
      const winds = [];
      const windDirs = [];
      const uvs = [];
      const luminositiesRaw = [];
      const cloudPercents = [];

      // R√©cup√©ration UV via OneCall API (car forecast ne donne pas UV)
      const lat = data.city.coord.lat;
      const lon = data.city.coord.lon;
      const nowUnix = Math.floor(Date.now()/1000);
      const oneCallRes = await fetch(`https://api.openweathermap.org/data/2.5/onecall?lat=${lat}&lon=${lon}&exclude=current,minutely,daily,alerts&appid=${apiKey}&units=${units}&lang=${lang}`);
      const oneCallData = await oneCallRes.json();

      const hourlyUVMap = {};
      oneCallData.hourly.forEach(h => {
        hourlyUVMap[h.dt] = h.uvi;
      });

      data.list.forEach(item => {
        const date = new Date(item.dt * 1000);
        const label = date.toLocaleString('fr-FR', { weekday: 'short', hour: '2-digit', minute: '2-digit' });
        labels.push(label);

        temps.push(item.main.temp);
        humidities.push(item.main.humidity);
        pressures.push(item.main.pressure);
        rains.push(item.rain?.["3h"] || 0);
        snows.push(item.snow?.["3h"] || 0);
        winds.push(item.wind.speed * 3.6);
        windDirs.push(item.wind.deg);

        // UV: on approxime par la valeur la plus proche dans oneCallData.hourly
        let closestUV = 0;
        let minDiff = 999999;
        for (const t in hourlyUVMap) {
          let diff = Math.abs(t - item.dt);
          if (diff < minDiff) {
            minDiff = diff;
            closestUV = hourlyUVMap[t];
          }
        }
        uvs.push(closestUV);

        // Luminosit√© brute = (100 - couverture nuageuse en %)
        luminositiesRaw.push(100 - (item.clouds?.all || 0));

        cloudPercents.push(item.clouds?.all || 0);
      });

      // Corriger luminosit√© en fonction n√©bulosit√©
      const luminosities = luminositiesRaw.map((lum, i) => luminosityCorrected(lum, cloudPercents[i]));

      // -- Mise √† jour graphiques --

      // Graphique principal
      const ctxMain = document.getElementById("mainChart").getContext("2d");
      if(mainChartInstance) mainChartInstance.destroy();
      mainChartInstance = new Chart(ctxMain, {
        type: 'line',
        data: {
          labels,
          datasets: [
            {
              label: "Temp√©rature (¬∞C)",
              data: temps,
              borderColor: "red",
              backgroundColor: "transparent",
              yAxisID: 'y1',
              tension: 0.3,
              fill: false,
              pointRadius: 3,
            },
            {
              label: "Humidit√© (%)",
              data: humidities,
              borderColor: "blue",
              backgroundColor: "transparent",
              yAxisID: 'y2',
              tension: 0.3,
              fill: false,
              pointRadius: 3,
            },
            {
              label: "Pluie + Neige (mm)",
              data: rains.map((r,i) => r + snows[i]),
              backgroundColor: "rgba(0,0,255,0.5)",
              type: 'bar',
              yAxisID: 'y3',
              borderRadius: 4,
            },
            {
              label: "Pression (hPa)",
              data: pressures,
              borderColor: "gray",
              borderDash: [5,5],
              fill: false,
              yAxisID: 'y4',
              tension: 0.3,
              pointRadius: 2,
            }
          ]
        },
        options: {
          responsive: true,
          interaction: { mode: 'index', intersect: false },
          stacked: false,
          scales: {
            y1: {
              type: 'linear',
              position: 'left',
              title: { display: true, text: 'Temp√©rature (¬∞C)' },
              grid: { drawOnChartArea: true },
              beginAtZero: false,
            },
            y2: {
              type: 'linear',
              position: 'right',
              offset: true,
              title: { display: true, text: 'Humidit√© (%)' },
              grid: { drawOnChartArea: false },
              beginAtZero: true,
              max: 100,
            },
            y3: {
              type: 'linear',
              position: 'right',
              offset: true,
              title: { display: true, text: 'Pr√©cipitations (mm)' },
              grid: { drawOnChartArea: false },
              beginAtZero: true,
            },
            y4: {
              type: 'linear',
              position: 'left',
              offset: true,
              title: { display: true, text: 'Pression (hPa)' },
              grid: { drawOnChartArea: false },
              beginAtZero: false,
            }
          },
          plugins: {
            legend: { position: 'top', labels: { boxWidth: 12, padding: 10 } },
            tooltip: {
              enabled: true, mode: 'nearest', intersect: false,
              callbacks: {
                label: context => {
                  const label = context.dataset.label || '';
                  let val = context.parsed.y;
                  if(label.includes('Direction du vent')) {
                    const deg = val;
                    const card = degToCardinal(deg);
                    return `${label}: ${deg}¬∞ (${card})`;
                  }
                  return label + ': ' + val;
                }
              }
            }
          }
        }
      });

      // Graphique secondaire (vent, UV, luminosit√© corrig√©e)
      const ctxWind = document.getElementById("windChart").getContext("2d");
      if(windChartInstance) windChartInstance.destroy();
      windChartInstance = new Chart(ctxWind, {
        type: 'line',
        data: {
          labels,
          datasets: [
            {
              label: "Vitesse du vent (km/h)",
              data: winds,
              borderColor: "#1f8ef1",
              backgroundColor: "transparent",
              yAxisID: 'y1',
              tension: 0.3,
              fill: false,
              pointRadius: 3,
            },
            {
              label: "Direction du vent (¬∞)",
              data: windDirs,
              borderColor: "#555",
              borderDash: [6,4],
              yAxisID: 'y2',
              fill: false,
              tension: 0.3,
              pointRadius: 2,
            },
            {
              label: "Indice UV",
              data: uvs,
              borderColor: "#f9c74f",
              backgroundColor: "transparent",
              yAxisID: 'y3',
              tension: 0.3,
              fill: false,
              pointRadius: 3,
            },
            {
              label: "Luminosit√© corrig√©e (%)",
              data: luminosities,
              borderColor: "#90be6d",
              backgroundColor: "transparent",
              yAxisID: 'y3',
              tension: 0.3,
              fill: false,
              pointRadius: 3,
            }
          ]
        },
        options: {
          responsive: true,
          interaction: { mode: 'index', intersect: false },
          stacked: false,
          scales: {
            y1: {
              type: 'linear',
              position: 'left',
              title: { display: true, text: 'Vitesse (km/h)' },
              beginAtZero: true,
            },
            y2: {
              type: 'linear',
              position: 'right',
              offset: true,
              title: { display: true, text: 'Direction (¬∞)' },
              beginAtZero: false,
              min: 0,
              max: 360,
              grid: { drawOnChartArea: false },
            },
            y3: {
              type: 'linear',
              position: 'right',
              offset: true,
              title: { display: true, text: 'UV & Luminosit√© (%)' },
              beginAtZero: true,
              max: 110,
              grid: { drawOnChartArea: false },
            }
          },
          plugins: {
            legend: { position: 'top', labels: { boxWidth: 12, padding: 10 } },
            tooltip: {
              enabled: true, mode: 'nearest', intersect: false,
              callbacks: {
                label: context => {
                  const label = context.dataset.label || '';
                  let val = context.parsed.y;
                  if(label.includes('Direction du vent')) {
                    const deg = val;
                    const card = degToCardinal(deg);
                    return `${label}: ${deg}¬∞ (${card})`;
                  }
                  return label + ': ' + val;
                }
              }
            }
          }
        }
      });

      return { forecastData: data, oneCallData: oneCallData };
    } catch (e) {
      console.error("Erreur r√©cup√©ration pr√©visions :", e);
      alert("Erreur lors de la r√©cup√©ration des pr√©visions m√©t√©o.");
      return null;
    }
  }

  // Affiche la qualit√© de l'air dans la liste et graphique
  async function fetchAirQuality() {
    try {
      // On r√©utilise lat lon de Zimmersheim fixe, ou √† r√©cup√©rer dynamiquement dans fetchForecast
      const lat = 47.7746;
      const lon = 7.3373;
      const res = await fetch(`https://api.openweathermap.org/data/2.5/air_pollution?lat=${lat}&lon=${lon}&appid=${apiKey}`);
      const data = await res.json();

      const list = document.getElementById("airQualityList");
      clearChildren(list);

      if(!data.list || data.list.length === 0) {
        list.innerHTML = "<li>Donn√©es indisponibles</li>";
        return null;
      }

      const air = data.list[0].components;
      airPollutantsLabels.forEach((label, i) => {
        const key = airPollutantsKeys[i];
        const val = air[key];
        const li = document.createElement("li");
        li.textContent = `${label} (${key.toUpperCase()}): ${val !== undefined ? val.toFixed(2) : 'N/A'} ¬µg/m¬≥`;
        list.appendChild(li);
      });

      // Mise √† jour graphique qualit√© air
      const ctxAir = document.getElementById("airChart").getContext("2d");
      if(airChartInstance) airChartInstance.destroy();

      airChartInstance = new Chart(ctxAir, {
        type: 'bar',
        data: {
          labels: airPollutantsLabels,
          datasets: [{
            label: "Concentration (¬µg/m¬≥)",
            data: airPollutantsKeys.map(k => air[k] || 0),
            backgroundColor: [
              "#ff6384", "#36a2eb", "#ffcd56",
              "#4bc0c0", "#9966ff", "#ff9f40"
            ]
          }]
        },
        options: {
          responsive: true,
          scales: {
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: "Concentration (¬µg/m¬≥)"
              }
            }
          },
          plugins: {
            legend: { display: false }
          }
        }
      });

      return air;
    } catch(e) {
      console.error("Erreur qualit√© de l'air :", e);
      alert("Erreur lors de la r√©cup√©ration des donn√©es qualit√© de l'air.");
      return null;
    }
  }

  async function main() {
    createStars();
    const weatherNow = await fetchWeather();
    const forecast = await fetchForecast();
    await fetchAirQuality();
  }

  main();

  // Recharger toutes les 15 minutes environ
  setInterval(main, 15*60*1000);

  // Recharger les animations et donn√©es au redimensionnement
  window.addEventListener('resize', () => {
    createStars();
  });
</script>

</body>
</html>
