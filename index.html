<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tableau de bord mÃ©tÃ©o â€” BoostÃ©</title>

  <!-- Chart.js + datalabels (CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2"></script>

  <style>
    /* ==== Chapitre 1 : Styles gÃ©nÃ©raux, thÃ¨mes sombre/clair ==== */
    :root{
      --bg: linear-gradient(to bottom, #87ceeb, #f0f8ff);
      --panel-bg: rgba(255,255,255,0.95);
      --text: #222;
      --muted: #555;
      --accent: #0077cc;
      --card-shadow: 0 0 30px rgba(0,0,0,0.08);
    }
    @media (prefers-color-scheme: dark){
      :root{
        --bg: linear-gradient(to bottom, #081229, #0b2940);
        --panel-bg: rgba(12,18,28,0.7);
        --text: #e9eef6;
        --muted: #bfc9d9;
        --accent: #66b2ff;
        --card-shadow: 0 0 30px rgba(0,0,0,0.6);
      }
    }

    html,body{height:100%;margin:0;font-family:Inter, "Segoe UI", Tahoma, Arial, sans-serif;background:var(--bg);color:var(--text);-webkit-font-smoothing:antialiased;}
    #background-anim{position:fixed;inset:0;z-index:-1;pointer-events:none;overflow:hidden}

    /* clouds */
    .cloud{position:absolute;background:linear-gradient(to bottom,#f0f4f8,#cbd6e8);border-radius:80px;opacity:.75;filter:drop-shadow(0 2px 6px rgba(0,0,0,.06));animation:cloudMove linear infinite}
    .cloud::before,.cloud::after{content:"";position:absolute;background:inherit;border-radius:50%}
    @keyframes cloudMove{0%{transform:translateX(-200px)}100%{transform:translateX(120vw)}}

    /* ==== Chapitre 2 : Layout ==== */
    #container{display:flex;max-width:1200px;margin:30px auto;gap:20px;flex-wrap:wrap;padding:0 16px}
    #left-panel{flex:1 1 340px;background:var(--panel-bg);border-radius:14px;padding:20px;box-shadow:var(--card-shadow);min-width:280px}
    #right-panel{flex:1 1 700px;background:var(--panel-bg);border-radius:14px;padding:20px;box-shadow:var(--card-shadow);min-width:300px}

    h1,h2{margin:0 0 12px 0;text-align:center}
    .info-row{display:flex;justify-content:space-between;align-items:center;margin:8px 0;font-size:1rem}
    .label{font-weight:700;color:var(--muted);min-width:140px}
    #condition-icon{display:block;margin:8px auto;width:96px;height:96px}

    /* wind arrow */
    #wind-arrow{display:inline-block;width:28px;height:28px;margin-left:8px;vertical-align:middle;transition:transform .4s ease;transform-origin:50% 60%}

    /* charts */
    section.chart-section{background:var(--panel-bg);margin:24px auto;border-radius:12px;padding:16px;box-shadow:var(--card-shadow);max-width:1200px}
    canvas{width:100% !important;max-height:420px !important}

    /* air legend */
    .air-legend{display:flex;flex-wrap:wrap;gap:12px;justify-content:center;margin-top:12px;font-size:14px}
    .air-legend div{display:flex;align-items:center;gap:8px}
    .air-legend span{display:inline-block;width:16px;height:16px;border-radius:3px}

    /* responsive */
    @media(max-width:900px){#container{padding-bottom:10px} #right-panel{order:3}}
  </style>
</head>
<body>
  <!-- ==== Chapitre 3 : fond animÃ© (nuages) ==== -->
  <div id="background-anim"></div>

  <!-- ==== Chapitre 4 : Conteneur principal ==== -->
  <div id="container">
    <!-- Gauche : mÃ©tÃ©o actuelle -->
    <div id="left-panel">
      <h1>MÃ©tÃ©o â€” Zimmersheim (boostÃ©e)</h1>
      <img id="condition-icon" src="" alt="IcÃ´ne mÃ©tÃ©o" />
      <div class="info-row"><span class="label">Condition :</span><span id="description">â€”</span></div>
      <div class="info-row"><span class="label">TempÃ©rature :</span><span id="temp">â€”</span> Â°C</div>
      <div class="info-row"><span class="label">Ressentie :</span><span id="feels-like">â€”</span> Â°C</div>
      <div class="info-row"><span class="label">Min / Max :</span><span id="temp-min">â€”</span> / <span id="temp-max">â€”</span> Â°C</div>
      <div class="info-row"><span class="label">HumiditÃ© :</span><span id="humidity">â€”</span> %</div>
      <div class="info-row"><span class="label">Nuages :</span><span id="clouds">â€”</span> %</div>
      <div class="info-row"><span class="label">PrÃ©cip. (1h) :</span><span id="precip">â€”</span></div>
      <div class="info-row"><span class="label">Pression :</span><span id="pressure">â€”</span> hPa</div>

      <div class="info-row">
        <span class="label">Vent :</span>
        <span><span id="wind">â€”</span> km/h</span>
        <svg id="wind-arrow" viewBox="0 0 24 24" fill="none" stroke="var(--accent)" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
          <line x1="12" y1="19" x2="12" y2="5"></line>
          <polyline points="5 12 12 5 19 12"></polyline>
        </svg>
      </div>
      <div class="info-row"><span class="label">Direction vent :</span><span id="wind-dir">â€”</span></div>

      <div class="info-row"><span class="label">Lever du soleil :</span><span id="sunrise">â€”</span></div>
      <div class="info-row"><span class="label">Coucher du soleil :</span><span id="sunset">â€”</span></div>
      <div class="info-row"><span class="label">Indice UV :</span><span id="uv-index">â€”</span></div>

      <div class="info-row">
        <span class="label">Phase lunaire :</span>
        <span id="moon-phase">â€”</span>
        <small id="moon-phase-desc" style="color:var(--muted);margin-left:8px">â€”</small>
      </div>

      <div style="margin-top:12px;text-align:center">
        <button id="refreshBtn" style="padding:8px 12px;border-radius:8px;border:0;background:var(--accent);color:white;cursor:pointer">RafraÃ®chir</button>
      </div>
    </div>

    <!-- Droite : qualitÃ© de l'air & alertes -->
    <div id="right-panel">
      <h2>QualitÃ© de l'air & Alertes</h2>
      <div id="air-quality-details">Chargementâ€¦</div>
      <div class="air-legend" style="margin-top:12px">
        <div><span style="background:#4caf50"></span> Excellente</div>
        <div><span style="background:#cddc39"></span> Acceptable</div>
        <div><span style="background:#ffc107"></span> Moyenne</div>
        <div><span style="background:#ff5722"></span> Mauvaise</div>
        <div><span style="background:#b71c1c"></span> TrÃ¨s mauvaise</div>
      </div>

      <h2 style="margin-top:18px">Alertes mÃ©tÃ©o</h2>
      <div id="alerts">Aucune alerte dÃ©tectÃ©e.</div>
    </div>
  </div>

  <!-- ==== Chapitre 5 : Graphiques ==== -->
  <section class="chart-section">
    <h2>ðŸ“Š PrÃ©visions horaires (48h)</h2>
    <canvas id="hourlyChart"></canvas>
  </section>

  <section class="chart-section">
    <h2>ðŸ“Š PrÃ©visions quotidiennes (7j)</h2>
    <canvas id="dailyChart"></canvas>
  </section>

  <section class="chart-section">
    <h2>ðŸ“Š QualitÃ© de l'air (derniÃ¨res valeurs)</h2>
    <canvas id="airChart"></canvas>
  </section>

  <!-- ==== Chapitre 6 : Script unique (tout le code) ==== -->
  <script>
  /**********************************************************************
   * Tableau de bord mÃ©tÃ©o - version boostÃ©e (UN SEUL FICHIER)
   * Source API principale : Open-Meteo (https://open-meteo.com)
   * Air quality : https://air-quality-api.open-meteo.com
   * Alerts : tentative via MeteoAlarm (si disponible)
   *
   * Structure :
   *  - Config & utilitaires
   *  - Cache (localStorage)
   *  - Fetch data (weather, air, alerts)
   *  - UI update
   *  - Charts (Chart.js) + plugin pour emoji/icÃ´nes sur points
   *
   * Auteur : gÃ©nÃ©ration par assistant â€” modifie latitude/longitude/city si besoin.
   **********************************************************************/

  /* ==== Chapitre 6.1 : Configuration ==== */
  const LAT = 47.7746;
  const LON = 7.3373;
  const CITY_NAME = "Zimmersheim, FR";
  const CACHE_KEY = "meteo_boost_data_v1";
  const CACHE_TTL_MS = 15 * 60 * 1000; // 15 minutes

  // Open-Meteo endpoints
  function buildOpenMeteoURL(lat, lon) {
    // hourly: temperature, apparent temp, humidity, precipitation, weathercode, windspeed, winddir, uv_index
    const hourly = [
      "temperature_2m",
      "apparent_temperature",
      "relativehumidity_2m",
      "precipitation",
      "weathercode",
      "windspeed_10m",
      "winddirection_10m",
      "uv_index"
    ].join(",");

    // daily: max/min temp, sunrise/sunset, uv_max, moonrise/moonset
    const daily = [
      "temperature_2m_max",
      "temperature_2m_min",
      "sunrise",
      "sunset",
      "uv_index_max",
      "moonrise",
      "moonset"
    ].join(",");

    const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}` +
                `&hourly=${hourly}&daily=${daily}&current_weather=true&timezone=auto&forecast_days=7`;
    return url;
  }

  // Air quality API (Open-Meteo Air Quality)
  function buildAirQualityURL(lat, lon) {
    const vars = ["pm10","pm2_5","carbon_monoxide","nitrogen_dioxide","ozone","sulphur_dioxide","ammonia"].join(",");
    return `https://air-quality-api.open-meteo.com/v1/air-quality?latitude=${lat}&longitude=${lon}&hourly=${vars}`;
  }

  // MeteoAlarm (tentative) â€” si indisponible le code gÃ¨re l'erreur proprement.
  function buildMeteoAlarmURL(lat, lon) {
    // Meteoalarm often requires region mapping; we try a public endpoint that may exist for EU.
    // NOTE: si ton projet demande alertes fiables, on peut intÃ©grer Meteoalarm via un mapping pays->zone.
    return `https://api.meteoalarm.org/v1/alerts/point?lat=${lat}&lon=${lon}`;
  }

  /* ==== Chapitre 6.2 : Utilitaires ==== */
  function nowMs(){ return Date.now(); }
  function degToCardinal(deg){
    const d = ["N","NNE","NE","ENE","E","ESE","SE","SSE","S","SSO","SO","OSO","O","ONO","NO","NNO"];
    return d[Math.round(((deg%360)+360)/22.5) % 16];
  }
  function formatTimeISO(s) {
    try { return new Date(s).toLocaleTimeString('fr-FR',{hour:'2-digit',minute:'2-digit'}); } catch(e){return s;}
  }
  function formatDateDaily(s) {
    try { return new Date(s).toLocaleDateString('fr-FR',{weekday:'short',day:'2-digit',month:'2-digit'}); } catch(e){return s;}
  }
  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

  /* ==== Chapitre 6.3 : Cache (localStorage) ==== */
  function saveCache(obj){
    const wrapped = { ts: nowMs(), data: obj };
    try { localStorage.setItem(CACHE_KEY, JSON.stringify(wrapped)); } catch(e){ console.warn("LocalStorage failed", e); }
  }
  function loadCache(){
    try {
      const txt = localStorage.getItem(CACHE_KEY);
      if(!txt) return null;
      const w = JSON.parse(txt);
      if(!w.ts || !w.data) return null;
      if(nowMs() - w.ts > CACHE_TTL_MS) return null;
      return w.data;
    } catch(e){ return null; }
  }
  function clearCache(){ localStorage.removeItem(CACHE_KEY); }

  /* ==== Chapitre 6.4 : Fetch data (Open-Meteo + Air + Alerts) ==== */
  async function fetchAllData({force=false} = {}){
    if(!force){
      const cached = loadCache();
      if(cached) return cached;
    }

    // fetch main weather
    const weatherURL = buildOpenMeteoURL(LAT, LON);
    const airURL = buildAirQualityURL(LAT, LON);
    const alertsURL = buildMeteoAlarmURL(LAT, LON);

    const results = { fetchedAt: nowMs(), city: CITY_NAME };

    try {
      const [wRes, aRes] = await Promise.all([
        fetch(weatherURL),
        fetch(airURL)
      ]);
      if(!wRes.ok) throw new Error('OpenMeteo error '+wRes.status);
      const wJson = await wRes.json();
      const aJson = aRes.ok ? await aRes.json() : null;

      results.weather = wJson;
      results.air = aJson;

    } catch(err){
      console.error("Fetch weather/air failed:", err);
      // If error and cache exists return cached stale
      const cached = loadCache();
      if(cached) return cached;
      throw err;
    }

    // try alerts (non-blocking)
    try {
      const alRes = await fetch(alertsURL);
      if(alRes.ok){
        results.alerts = await alRes.json();
      } else {
        results.alerts = null;
      }
    } catch(e){ results.alerts = null; }

    saveCache(results);
    return results;
  }

  /* ==== Chapitre 6.5 : Mapping weathercode -> emoji/icon ==== */
  // Open-Meteo weathercode mapping (simplified)
  const weatherCodeMap = {
    0: {icon:'â˜€ï¸', label:'Ciel dÃ©gagÃ©'},
    1: {icon:'ðŸŒ¤ï¸', label:'Principalement ensoleillÃ©'},
    2: {icon:'â›…', label:'Partiellement nuageux'},
    3: {icon:'â˜ï¸', label:'Nuageux'},
    45: {icon:'ðŸŒ«ï¸', label:'Brouillard'},
    48: {icon:'ðŸŒ«ï¸', label:'Brouillard avec dÃ©pÃ´ts'},
    51: {icon:'ðŸŒ¦ï¸', label:'Pluie lÃ©gÃ¨re (gouttes)'},
    53: {icon:'ðŸŒ§ï¸', label:'Pluie modÃ©rÃ©e'},
    55: {icon:'ðŸŒ§ï¸', label:'Pluie forte'},
    61: {icon:'ðŸŒ§ï¸', label:'Pluie faible'},
    63: {icon:'ðŸŒ§ï¸', label:'Pluie'},
    65: {icon:'â›ˆï¸', label:'Pluie forte / orage'},
    71: {icon:'ðŸŒ¨ï¸', label:'Neige'},
    73: {icon:'ðŸŒ¨ï¸', label:'Neige forte'},
    75: {icon:'â„ï¸', label:'Chutes de neige intenses'},
    80: {icon:'ðŸŒ¦ï¸', label:'Averses lÃ©gÃ¨res'},
    81: {icon:'ðŸŒ§ï¸', label:'Averses'},
    82: {icon:'â›ˆï¸', label:'Averses violentes'},
    95: {icon:'â›ˆï¸', label:'Orage'},
    96: {icon:'â›ˆï¸', label:'Orage avec grÃªle'},
    99: {icon:'â›ˆï¸', label:'Orage violent'}
  };

  function wcIcon(code){ return (weatherCodeMap[code] && weatherCodeMap[code].icon) || 'ðŸŒˆ'; }
  function wcLabel(code){ return (weatherCodeMap[code] && weatherCodeMap[code].label) || ('Code ' + code); }

  /* ==== Chapitre 6.6 : UI update helpers ==== */
  function setText(id, txt){ const el = document.getElementById(id); if(el) el.textContent = (txt === undefined || txt === null) ? 'â€”' : txt; }
  function setImg(id, src){ const el = document.getElementById(id); if(el) el.src = src; }

  /* ==== Chapitre 6.7 : Charts setup (global vars) ==== */
  let hourlyChart = null, dailyChart = null, airChart = null;

  // plugin: draw emoji/icon on points (non-invasive)
  const EmojiPointPlugin = {
    id: 'emojiPoint',
    afterDatasetsDraw(chart, args, options) {
      const { ctx, chartArea } = chart;
      chart.data.datasets.forEach((ds, i) => {
        if(!ds.icons) return; // icons array optional
        const meta = chart.getDatasetMeta(i);
        meta.data.forEach((point, idx) => {
          const icon = ds.icons[idx];
          if(!icon) return;
          const { x, y } = point.getProps(['x','y'], true);
          ctx.save();
          ctx.font = `${Math.round((options && options.fontSize) || 14)}px serif`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(icon, x, y - 18); // draw above point
          ctx.restore();
        });
      });
    }
  };

  Chart.register(ChartDataLabels, EmojiPointPlugin);

  /* ==== Chapitre 6.8 : Build Charts ==== */
  function createHourlyChart(labels, temps, hums, winds, windDirs, weatherIcons){
    const ctx = document.getElementById('hourlyChart').getContext('2d');
    if(hourlyChart) hourlyChart.destroy();

    // gradient for temperature
    const grad = ctx.createLinearGradient(0,0,0,300);
    grad.addColorStop(0, 'rgba(255,99,132,0.7)');
    grad.addColorStop(1, 'rgba(255,99,132,0.05)');

    hourlyChart = new Chart(ctx, {
      type: 'line',
      data: {
        labels,
        datasets: [
          {
            label: 'Temp (Â°C)',
            data: temps,
            borderColor: 'rgba(255,99,132,0.9)',
            backgroundColor: grad,
            fill: true,
            tension: 0.25,
            yAxisID: 'y',
            icons: weatherIcons
          },
          {
            label: 'HumiditÃ© (%)',
            data: hums,
            borderColor: 'rgba(54,162,235,0.9)',
            fill: false,
            yAxisID: 'y1',
            tension: 0.25
          },
          {
            label: 'Vent (km/h)',
            data: winds,
            borderColor: 'rgba(0,123,255,0.9)',
            fill: false,
            yAxisID: 'y2',
            tension: 0.25
          }
        ]
      },
      options: {
        responsive: true,
        interaction: { mode: 'index', intersect: false },
        plugins: {
          legend: { position: 'top' },
          tooltip: {
            callbacks: {
              label: (ctx) => {
                const ds = ctx.dataset.label;
                return `${ds}: ${ctx.parsed.y}${ds.includes('Temp') ? ' Â°C' : ds.includes('HumiditÃ©') ? ' %' : ' km/h'}`;
              }
            }
          },
          emojiPoint: { fontSize: 16 }
        },
        scales: {
          y: { position: 'left', title: { display: true, text: 'Temp (Â°C)' } },
          y1: { position: 'right', grid: { drawOnChartArea: false }, title: { display: true, text: 'HumiditÃ© (%)' }, min:0, max:100 },
          y2: { position: 'right', grid: { drawOnChartArea: false }, title: { display: true, text: 'Vent (km/h)' }, min:0 }
        }
      }
    });
  }

  function createDailyChart(labels, tmin, tmax, icons){
    const ctx = document.getElementById('dailyChart').getContext('2d');
    if(dailyChart) dailyChart.destroy();

    const gradUp = ctx.createLinearGradient(0,0,0,200);
    gradUp.addColorStop(0,'rgba(255,99,132,0.8)');
    gradUp.addColorStop(1,'rgba(255,99,132,0.05)');

    dailyChart = new Chart(ctx, {
      type: 'bar',
      data: {
        labels,
        datasets: [
          { label: 'T. min (Â°C)', data: tmin, backgroundColor: 'rgba(54,162,235,0.8)', icons },
          { label: 'T. max (Â°C)', data: tmax, backgroundColor: gradUp, icons }
        ]
      },
      options: {
        responsive: true,
        plugins: {
          legend: { position: 'top' },
          tooltip: {
            callbacks: {
              label: (ctx) => `${ctx.dataset.label}: ${ctx.parsed.y} Â°C`
            }
          },
          emojiPoint: { fontSize: 18 }
        },
        scales: {
          y: { beginAtZero: false, title: { display: true, text: 'Temp (Â°C)' } }
        }
      }
    });
  }

  function createAirChart(labels, values){
    const ctx = document.getElementById('airChart').getContext('2d');
    if(airChart) airChart.destroy();

    const colors = labels.map(k => {
      if(k.includes('pm2_5')) return '#ff5722';
      if(k.includes('pm10')) return '#ff9800';
      if(k.includes('carbon')) return '#4caf50';
      return '#9e9e9e';
    });

    airChart = new Chart(ctx, {
      type: 'bar',
      data: { labels, datasets: [{ label: 'Concentration (Âµg/mÂ³)', data: values, backgroundColor: colors }] },
      options: { responsive:true, plugins:{datalabels:{anchor:'end',align:'top',formatter:v=>parseFloat(v).toFixed(2)}}, scales:{y:{beginAtZero:true}} }
    });
  }

  /* ==== Chapitre 6.9 : Main render/update function ==== */
  async function renderAll({force=false} = {}){
    try {
      setText('description', 'Chargementâ€¦');
      const data = await fetchAllData({force});
      const w = data.weather;
      const a = data.air;
      const alerts = data.alerts;

      // current weather (open-meteo returns current_weather object)
      const cur = w.current_weather || {};
      const hourly = w.hourly || {};
      const daily = w.daily || {};

      // update left panel (safely)
      setText('description', (wcLabel(cur.weathercode) || cur.weathercode));
      setText('temp', cur.temperature !== undefined ? Math.round(cur.temperature) : 'â€”');
      setText('feels-like', hourly.apparent_temperature ? hourly.apparent_temperature[0].toFixed(1) : 'â€”');
      setText('temp-min', (daily.temperature_2m_min && daily.temperature_2m_min[0] !== undefined) ? daily.temperature_2m_min[0].toFixed(1) : 'â€”');
      setText('temp-max', (daily.temperature_2m_max && daily.temperature_2m_max[0] !== undefined) ? daily.temperature_2m_max[0].toFixed(1) : 'â€”');
      setText('humidity', hourly.relativehumidity_2m ? Math.round(hourly.relativehumidity_2m[0]) : 'â€”');
      setText('pressure', 'â€”'); // Open-Meteo current endpoint doesn't always include pressure in free call
      setText('precip', (hourly.precipitation && hourly.precipitation[0] ? hourly.precipitation[0] + ' mm' : 'Aucune'));
      setText('clouds', '-'); // We could derive from weathercode
      setText('wind', cur.windspeed !== undefined ? Math.round(cur.windspeed * 3.6) : 'â€”'); // open-meteo in m/s? for 10m winds default is m/s; but we used windspeed_10m (m/s) -> convert to km/h
      setText('wind-dir', (cur.winddirection !== undefined ? `${degToCardinal(cur.winddirection)} (${cur.winddirection}Â°)` : 'â€”'));
      setText('uv-index', (hourly.uv_index && hourly.uv_index[0] !== undefined) ? hourly.uv_index[0] : 'â€”');

      // sunrise/sunset (daily arrays)
      setText('sunrise', daily.sunrise && daily.sunrise[0] ? formatTimeISO(daily.sunrise[0]) : 'â€”');
      setText('sunset', daily.sunset && daily.sunset[0] ? formatTimeISO(daily.sunset[0]) : 'â€”');

      // moon: use daily moonrise/moonset and compute phase simple
      if(daily.moonrise && daily.moonrise[0]) {
        setText('moon-phase', computeMoonEmoji(new Date())); // computed below
        setText('moon-phase-desc', computeMoonDescription(new Date()));
      }

      // condition icon: choose from weathercode
      const iconEmoji = wcIcon(cur.weathercode);
      // small SVG data as src (we'll use an SVG with emoji text to keep it self-contained)
      const svg = `<svg xmlns='http://www.w3.org/2000/svg' width='128' height='128'><foreignObject width='100%' height='100%'><div xmlns='http://www.w3.org/1999/xhtml' style='font-size:72px;display:flex;align-items:center;justify-content:center;height:100%;'>${iconEmoji}</div></foreignObject></svg>`;
      const svgSrc = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svg);
      setImg('condition-icon', svgSrc);

      // rotate wind arrow â€” pointe vers la direction vers laquelle le vent souffle
      const arrow = document.getElementById('wind-arrow');
      if(arrow && cur.winddirection !== undefined){
        arrow.style.transformOrigin = '50% 60%';
        arrow.style.transform = `rotate(${cur.winddirection}deg)`;
        // --- si tu veux indiquer d'oÃ¹ vient le vent (compass origin), fais : rotate(${cur.winddirection+180}deg)
      }

      // --- Graph: hourly (take next 48 values)
      const times = (hourly.time || []).slice(0, 48);
      const temps = (hourly.temperature_2m || []).slice(0, 48).map(v => parseFloat(v.toFixed(1)));
      const hums = (hourly.relativehumidity_2m || []).slice(0, 48).map(v => Math.round(v));
      const windSpeeds = (hourly.windspeed_10m || []).slice(0, 48).map(v => Math.round(v * 3.6)); // m/s -> km/h
      const windDirs = (hourly.winddirection_10m || []).slice(0, 48).map(v => Math.round(v));
      const weatherCodes = (hourly.weathercode || []).slice(0, 48);

      const hourLabels = times.map(t => {
        const d = new Date(t);
        return d.toLocaleString('fr-FR',{hour:'2-digit',day:'2-digit',month:'2-digit'});
      });

      const hourIcons = weatherCodes.map(c => wcIcon(c));

      createHourlyChart(hourLabels, temps, hums, windSpeeds, windDirs, hourIcons);

      // --- Graph: daily (7 days)
      const dTimes = (daily.time || []).slice(0, 7);
      const dLabels = dTimes.map(t => formatDateDaily(new Date(t)));
      const dMin = (daily.temperature_2m_min || []).slice(0,7).map(v=>parseFloat(v.toFixed(1)));
      const dMax = (daily.temperature_2m_max || []).slice(0,7).map(v=>parseFloat(v.toFixed(1)));
      // approximate icon: pick weather code from hourly middle of day
      const dIcons = (dTimes || []).map((dt, idx) => {
        // search hourly around midday
        const midday = new Date(dt); midday.setHours(12,0,0,0);
        const idxHourly = (hourly.time || []).findIndex(t => new Date(t).getDate() === midday.getDate());
        const code = (hourly.weathercode && hourly.weathercode[idxHourly]) || 0;
        return wcIcon(code);
      });
      createDailyChart(dLabels, dMin, dMax, dIcons);

      // --- Air chart (latest hour values)
      if(a && a.hourly){
        // find last timestamp index
        const aTimes = a.hourly.time || [];
        const lastIdx = aTimes.length - 1;
        const components = Object.keys(a.hourly).filter(k => k !== 'time');
        const labels = components;
        const values = components.map(k => {
          const arr = a.hourly[k] || [];
          const v = arr[lastIdx] || 0;
          return parseFloat(v.toFixed(2));
        });
        createAirChart(labels, values);

        // update textual air details
        const html = components.map((k, i) => {
          const val = values[i];
          return `<div style="margin:6px 0"><b>${k}</b> : ${val} Âµg/mÂ³ ${interpretAirQualitySimple(k,val)}</div>`;
        }).join("");
        document.getElementById('air-quality-details').innerHTML = html;
      } else {
        document.getElementById('air-quality-details').textContent = "DonnÃ©es qualitÃ© de l'air non disponibles.";
      }

      // --- Alerts
      renderAlerts(alerts);

    } catch (err) {
      console.error("renderAll failed", err);
      setText('description', 'Erreur de chargement');
      document.getElementById('alerts').textContent = 'Impossible de charger les donnÃ©es â€” vÃ©rifie la console.';
    }
  }

  /* ==== Chapitre 6.10 : Alerts rendering (graceful) ==== */
  function renderAlerts(alertsData){
    const el = document.getElementById('alerts');
    if(!alertsData){
      el.textContent = 'Aucune alerte dÃ©tectÃ©e (ou service alerte indisponible).';
      return;
    }
    try {
      if(Array.isArray(alertsData) && alertsData.length===0){ el.textContent = 'Aucune alerte.'; return; }
      // If alerts object: display important fields
      const html = (alertsData.features || alertsData).slice(0,10).map(it => {
        // adapt to possible schema
        const title = it.properties?.headline || it.title || it.event || 'Alerte';
        const desc = it.properties?.description || it.description || '';
        return `<div style="margin-bottom:8px;padding:8px;border-radius:8px;background:rgba(255,230,230,.06)"><b>${title}</b><div style="font-size:.9rem;color:var(--muted)">${desc}</div></div>`;
      }).join('');
      el.innerHTML = html || 'Aucune alerte significative.';
    } catch(e){
      el.textContent = 'Aucune alerte (format inattendu).';
    }
  }

  /* ==== Chapitre 6.11 : Air quality interpretation (simple) ==== */
  function interpretAirQualitySimple(key, val){
    // Very simple thresholds for user friendliness (not regulatory)
    if(val <= 10) return '(Excellente)';
    if(val <= 25) return '(Acceptable)';
    if(val <= 50) return '(Moyenne)';
    if(val <= 100) return '(Mauvaise)';
    return '(TrÃ¨s mauvaise)';
  }

  /* ==== Chapitre 6.12 : Moon phase helpers ==== */
  function computeMoonEmoji(date){
    const phase = getMoonPhaseIndex(date);
    const phases = ['ðŸŒ‘','ðŸŒ’','ðŸŒ“','ðŸŒ”','ðŸŒ•','ðŸŒ–','ðŸŒ—','ðŸŒ˜'];
    return phases[phase] || 'ðŸŒ•';
  }
  function computeMoonDescription(date){
    const phase = getMoonPhaseIndex(date);
    const labels = ['Nouvelle lune','Premier croissant','Premier quartier','Gibbeuse croissante','Pleine lune','Gibbeuse dÃ©croissante','Dernier quartier','Dernier croissant'];
    return labels[phase] || '';
  }
  function getMoonPhaseIndex(date){
    // simple algorithm (approx)
    const lp = 2551443; // lunar period in seconds
    const new_moon = new Date(1970,0,7,20,35,0).getTime();
    const phase = ((date.getTime() - new_moon) / 1000) % lp;
    const percent = phase / lp;
    return Math.floor(percent * 8) % 8;
  }

  /* ==== Chapitre 6.13 : Interaction / startup ==== */
  document.getElementById('refreshBtn').addEventListener('click', ()=> {
    clearCache();
    renderAll({force:true});
  });

  // create decorative clouds (non-essential)
  (function spawnClouds(){
    const bg = document.getElementById('background-anim');
    for(let i=0;i<6;i++){
      const c = document.createElement('div'); c.classList.add('cloud');
      const size = Math.random() * 140 + 80;
      c.style.width = size + 'px'; c.style.height = (size*0.6) + 'px';
      c.style.top = (Math.random()*60) + 'px';
      c.style.left = (-200 + Math.random()*400) + 'px';
      c.style.opacity = 0.5 + Math.random()*0.5;
      c.style.animationDuration = (30 + Math.random()*60) + 's';
      bg.appendChild(c);
    }
  })();

  // init
  (async () => {
    await renderAll();
    // auto-refresh every 15 minutes (you can change)
    setInterval(()=>renderAll(), 15*60*1000);
  })();

  </script>
</body>
</html>
